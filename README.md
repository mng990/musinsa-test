### 구현 요구사항

이 프로젝트에서는 무신사 과제를 수행하기 위해 다음과 같은 주요 기능을 API로 구현하였습니다:

1. **카테고리별 최저 가격 조회 API**

   - 고객은 각 카테고리별로 **최저 가격의 브랜드**와 **가격**을 조회하고, **총액**을 확인할 수 있습니다.
   - 해당 API는 모든 상품 데이터를 조회하여, 카테고리별 최저가 정보를 제공하는 역할을 합니다.

2. **단일 브랜드 최저 가격 조회 API**

   - 고객은 단일 브랜드로 모든 카테고리 상품을 구매할 경우, **최저 가격의 브랜드**와 **총액**을 확인할 수 있습니다.
   - 이 API는 모든 브랜드의 데이터를 비교하여, **가장 저렴하게 모든 카테고리를 구매**할 수 있는 브랜드를 추천합니다.

3. **카테고리 내 최저 및 최고 가격 브랜드 조회 API**

   - 특정 카테고리에서 **최저 가격**과 **최고 가격의 브랜드**를 확인하고, 해당 **브랜드의 상품 가격**을 조회할 수 있습니다.

4. **브랜드 및 상품 추가/업데이트/삭제 API**

   - 운영자는 **새로운 브랜드를 등록**하거나, 기존 브랜드의 **상품을 추가, 업데이트, 삭제**할 수 있습니다.
   - 이를 통해 지속적으로 **브랜드 및 상품 정보를 관리**할 수 있습니다.

### 데이터베이스 모델 (ERD)

![QuickDBD-musinsa-test (1)](https://github.com/user-attachments/assets/367bc45a-e4dd-4903-9984-17b2c06e7e8c)  
프로젝트에서 사용된 데이터베이스 모델의 **ERD**입니다.  
주요 엔티티와 속성은 다음과 같습니다.  

#### Brand
- id (BIGINT): 브랜드 고유 식별자
- name (VARCHAR(100)): 브랜드 이름
- created_at (TIMESTAMP): 생성 시간
- updated_at (TIMESTAMP): 업데이트 시간

#### Category
- id (BIGINT): 카테고리 고유 식별자
- name (VARCHAR(50)): 카테고리 이름
- created_at (TIMESTAMP): 생성 시간
- updated_at (TIMESTAMP): 업데이트 시간

#### Product
- id (BIGINT): 상품 고유 식별자
- price (BIGINT): 상품 가격
- category_id (BIGINT): 상품이 속한 카테고리 ID (Category와의 외래키 관계)
- brand_id (BIGINT): 상품이 속한 브랜드 ID (Brand와의 외래키 관계)
- created_at (TIMESTAMP): 생성 시간
- updated_at (TIMESTAMP): 업데이트 시간



### 패키지 구조 설명 (Musinsa Showcase 프로젝트)

프로젝트는 **클린 아키텍처**를 기반으로 **도메인, 어댑터, 애플리케이션 계층**을 분리하여 유지보수성과 응집도를 높이고 있습니다.  
각 패키지의 역할은 다음과 같습니다.

```
└── com
    └── musinsa
        ├── common
        │   ├── config
        │   ├── dto
        │   ├── entity
        │   └── exception
        ├── showcase
        │   ├── adapter
        │   │   ├── in
        │   │   └── out
        │   ├── application
        │   │   ├── mapper
        │   │   ├── port
        │   │   │   ├── in
        │   │   │   └── out
        │   │   └── service
        │   └── domain
        │       ├── Brand
        │       ├── Category
        │       └── Product
        └── AssignmentApplication
```

#### 1. **common**

- **config**: 프로젝트에서 전역적으로 사용되는 설정 파일들이 포함됩니다.
- **dto**: 공용 DTO를 모아둔 패키지로, 계층 간 데이터 전달을 위해 사용됩니다. 공통으로 사용되는 **response**와 **error code**를 정리해 놓은 곳입니다.
- **entity**: 공용 엔티티 클래스(etc. BaseEntity)들이 모여 있으며, 데이터베이스 매핑에 사용됩니다.
- **exception**: 프로젝트 전반에서 발생할 수 있는 예외 처리를 관리하는 클래스들이 포함되어 있습니다.

#### 2. **showcase**

- **adapter**: 외부 시스템과의 상호작용을 담당하는 계층입니다.
  - **in**: 클라이언트의 요청을 처리하는 어댑터, 예를 들어 REST 컨트롤러가 위치합니다.
  - **out**: 외부 시스템과의 통신을 위한 어댑터로, 데이터베이스 접근이나 외부 API 호출과 관련된 클래스들이 있습니다.
- **application**: 비즈니스 로직을 처리하는 계층입니다.
  - **mapper**: 도메인 객체와 DTO 간의 변환을 처리하는 매퍼 클래스들이 포함됩니다.
  - **port**: 비즈니스 로직의 입출력을 정의하는 인터페이스를 모아둔 패키지입니다.
    - **in**: 
    애플리케이션 내부로 들어오는 요청을 처리하기 위한 인터페이스를 정의합니다. 주로 **유스케이스**와 관련된 비즈니스 작업을 처리합니다.
    - **out**: 애플리케이션에서 외부 시스템으로 나가는 작업을 정의하는 인터페이스입니다. 데이터베이스 저장소나 외부 API 호출 등과 같은 작업을 위해 사용됩니다.
  - **service**: 비즈니스 유스케이스를 구현한 서비스 클래스들이 위치합니다.
- **domain**: 비즈니스의 핵심 개념을 표현하는 **Brand**, **Category**, **Product** 엔티티들이 포함되어 있으며, 각 도메인은 프로젝트의 주요 개념을 반영하고 있습니다.

#### 3. **AssignmentApplication**

- 프로젝트의 진입점(Entry Point)으로, 애플리케이션을 실행하기 위한 메인 클래스입니다.

#### 4. 응답 객체
```
{
	"status": "OK",
  "timestamp": "2024-10-22 19:33:08",
	"data": {
      "최저가" : {
         "브랜드" : "D",
         "카테고리" : [
            {"카테고리" : "상의", "가격" : "10,100"},
            {"카테고리" : "아우터", "가격" : "5,100"},
            {"카테고리" : "바지", "가격" : "3,000"},
            {"카테고리" : "스니커즈", "가격" : "9,500"},
            {"카테고리" : "가방", "가격" : "2,500"},
            {"카테고리" : "모자", "가격" : "1,500"},
            {"카테고리" : "양말", "가격" : "2,400"},
            {"카테고리" : "액세서리", "가격" : "2,000"}
         ],
         "총액" : "36,100"
      }
}
}
```
- 로그 추적을 위해 status와 timestamp를 추가로 기록
- API 응답 데이터는 data 필드에 삽입

### 빌드, 테스트, 실행 방법

1. **빌드**: 해당 프로젝트는 Gradle을 사용하여 빌드할 수 있습니다. 프로젝트 루트 디렉토리에서 다음 명령어를 사용하세요.

   ```
   ./gradlew build
   ```

2. **테스트**: 다음 명령어로 테스트를 실행할 수 있습니다.

   ```
   ./gradlew test
   ```

3. **실행**: 애플리케이션을 실행하려면 다음 명령어를 사용하세요.

   ```
   ./gradlew bootRun
   ```

4. **H2 데이터베이스**: 로컬 환경에서 테스트하기 위해 H2 데이터베이스(인메모리)를 사용합니다. 애플리케이션을 실행한 후, `http://localhost:8080/h2-console`에서 데이터베이스에 접근할 수 있습니다.
5. 구현 의도 및 프로잭트 진행은 github Issue와 Project로 기록했습니다. 
